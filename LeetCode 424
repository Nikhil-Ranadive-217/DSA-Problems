Problem:- Longest Repeating Character ReplacementMedium

You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.

Return the length of the longest substring containing the same letter you can get after performing the above operations.

Example 1:

Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.

Solutions:- 

LeetCode 424: Longest Repeating Character Replacement finds max substring length where ≤k chars can be changed to make all identical. Sliding window + max frequency tracking.

#Java Implementation (Sliding Window)

class Solution {
    public int characterReplacement(String s, int k) {
        int[] count = new int[26];
        int maxLen = 0;
        int left = 0;
        int maxCount = 0;  // Most frequent char in window
        
        for (int right = 0; right < s.length(); right++) {
            // Add right char
            char c = s.charAt(right);
            count[c - 'A']++;
            maxCount = Math.max(maxCount, count[c - 'A']);
            
            // Shrink if invalid: (right-left+1) > (maxCount + k)
            while (right - left + 1 - maxCount > k) {
                count[s.charAt(left) - 'A']--;
                left++;
            }
            
            maxLen = Math.max(maxLen, right - left + 1);
        }
        
        return maxLen;
    }
}

Window condition: window_length ≤ max_frequency + k

#Step-by-Step Logic
Count array: Track 26 uppercase chars
Sliding window: left to right
For each right:
Update count[c], maxCount
While invalid: len > maxCount + k → shrink left
Update maxLen
Result: maxLen
Trace: "ABAB", k=2

text
r=0 A: count[A]=1, maxC=1, len=1≤3 ✓
r=1 B: count[A]=1,B=1, maxC=1, len=2≤3 ✓  
r=2 A: count[A]=2,B=1, maxC=2, len=3≤4 ✓
r=3 B: count[A]=2,B=2, maxC=2, len=4≤4 ✓ → 4

#Thought Process
Key insight:

text
After k replacements, substring becomes:
[max_freq chars stay] + [k chars changed to match]
Total length = max_freq + k
Window valid iff: window_length ≤ max_frequency + k

Why shrink left: Remove least contributing chars first
Why maxCount: Only most frequent char matters for replacements

Time: O(n), Space: O(1)

#Edge Cases
k ≥ n: Whole string ✓
k=0: Longest run of identical chars
All same: "AAAA", k=0 → 4
Alternating: "ABABAB", k=2 → 4
