Problem:-Permutation in String
Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.

In other words, return true if one of s1's permutations is the substring of s2.

Example 1:

Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains one permutation of s1 ("ba").

Solutions:-

Permutation in String checks if s2 contains any permutation of s1 as contiguous substring. Sliding window + char count matching.

Java Implementation (Sliding Window)
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        if (s1.length() > s2.length()) return false;
        
        int[] count = new int[26];
        
        // Count s1 characters
        for (char c : s1.toCharArray()) {
            count[c - 'a']++;
        }
        
        int matches = 0;
        
        // Slide fixed-size window over s2
        for (int i = 0; i < s2.length(); i++) {
            // Add new character (right end)
            char rightChar = s2.charAt(i);
            count[rightChar - 'a']--;
            if (count[rightChar - 'a'] >= 0) {
                matches++;
            }
            
            // Remove old character (left end) - only if window full size
            if (i >= s1.length()) {
                char leftChar = s2.charAt(i - s1.length());
                if (count[leftChar - 'a']++ >= 0) {
                    matches--;
                }
            }
            
            // Check if window matches s1
            if (matches == s1.length()) {
                return true;
            }
        }
        
        return false;
    }
}

    }
}

Fixed window: Size s1.length(), track matching chars.

#Step-by-Step Logic
Count s1: count[c]++
Initial s2 window: Slide s1.length() chars, track matched
#Slide window:
Remove oldC: if was matching (count==-1), matched--
Add newC: if matches target (count>=0), matched++
matched == s1.length() → permutation found

#Thought Process
Brute: Check every s2 substring → O(n*m!) TLE.
Sliding window: Fixed size s1.length(), permutation iff char counts match.
Optimization: Track matched count instead of full equality check each time.
Why count[oldC]++ == -1: Was matching (count=-1 before ++).
Time: O(n), Space: O(1)

#Edge Cases
s1 longer: Immediate false
s1 empty: Edge case true (vacuous)
Exact match: Works
s1 all same: "aaa" in "abaaa" ✓
