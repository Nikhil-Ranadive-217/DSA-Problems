Leetcode problem no. 238. Product of Array Except Self

" Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].
The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
You must write an algorithm that runs in O(n) time and without using the division operation.

Example 1:
Input: nums = [1,2,3,4]
Output: [24,12,8,6]

Solution:
LeetCode 238: Product of Array Except Self computes answer[i] = product of all nums[j] where j != i, O(n) time, NO division.[conversation_history]

#Java Implementation (Left-Right Pass)

class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] answer = new int[n];
        
        // Left pass: answer[i] = product of all left of i
        answer[0] = 1;
        for (int i = 1; i < n; i++) {
            answer[i] = answer[i-1] * nums[i-1];
        }
        
        // Right pass: multiply right products
        int rightProd = 1;
        for (int i = n-2; i >= 0; i--) {
            rightProd *= nums[i+1];
            answer[i] *= rightProd;
        }
        
        return answer;
    }
}

Two-pass genius: Left products → right multiply. O(n) time, O(1) extra space.[conversation_history]

#Step-by-Step Logic
Left pass: answer[i] = nums[0] * nums[1] * ... * nums[i-1]
Right pass: For each i, multiply by nums[i+1] * ... * nums[n-1]
Result: answer[i] now holds full product except nums[i].

Example trace: [1,2,3,4]

Left:  [1, 1, 2, 6]  (products left of i)
Right: [24,12,8,6]  (× right products)

#Thought Process
Naive: Product all × divide nums[i] → O(n²) or division violation.
Prefix insight: Need left/right products for each i. Prefix array too space-heavy.
Two-pass magic: Reuse answer array for left pass, accumulate right on second pass. Space drops to O(1)!
No division: Pure multiplication, handles zeroes perfectly.

#Edge Cases
All 1s: [1,1,1] → [1,1,1] (products=1).[conversation_history]
Single element: [5] → [1] (no others).[conversation_history]
Zeroes:
One zero: [-1,0,1] → [0, -1, 0]
Multiple zeroes: All others → 0
Negatives: [-1,-2,-3] → [6,3,2] (signs handled).
Max n=10^5: O(n) fine, 32-bit guarantee.
