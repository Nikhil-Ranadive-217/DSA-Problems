Problem:-Remove Duplicates from Sorted Array
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.

Consider the number of unique elements in nums to be k​​​​​​​​​​​​​​. After removing duplicates, return the number of unique elements k.

The first k elements of nums should contain the unique numbers in sorted order. The remaining elements beyond index k - 1 can be ignored.

Custom Judge:

The judge will test your solution with the following code:

int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
If all assertions pass, then your solution will be accepted.

Example 1:

Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

Solutions:-

LeetCode 26: Remove Duplicates from Sorted Array compacts sorted nums in-place, removing duplicates while preserving order. Returns k (unique count).[conversation_history]

#Java Implementation (Two Pointers)

class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length == 0) return 0;
        
        int write = 1;  // Next position to write
        
        for (int read = 1; read < nums.length; read++) {
            if (nums[read] != nums[read - 1]) {
                nums[write] = nums[read];
                write++;
            }
        }
        
        return write;
    }
}

Read-write pointers: read scans, write compacts unique elements.

#Step-by-Step Logic
Edge: Empty array → 0
write=1: Assume nums[0] valid
read=1 to end:
If nums[read] != nums[read-1] → unique!
Copy to nums[write++]
Return: write = unique count
Trace: [1,1,2]

read=1: 1==1 → skip
read=2: 2!=1 → nums[1]=2, write=2
Return: 2 ✓ nums=[1,2,_]

#Thought Process
Sorted key: Duplicates consecutive! Compare adjacent only.

Two roles:
read: Scans input
write: Builds compacted output
Why write=1: nums[0] always kept (first occurrence).
Time: O(n), Space: O(1) in-place.
Beauty: Single pass, no extra allocation!

#Edge Cases
Empty: [] → 0 ✓
Single: [1] → 1 ✓
All unique: [1,2,3,4] → 4 (write follows read)
All duplicates: [1,1,1,1] → 1 (write stays 1)
Mixed: [1,1,2,2,3] → 3 ✓
