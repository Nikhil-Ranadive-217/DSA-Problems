Problem:-Asteroid Collision

We are given an array asteroids of integers representing asteroids in a row. The indices of the asteroid in the array represent their relative position in space.
For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.
Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.

Example 1:

Input: asteroids = [5,10,-5]
Output: [5,10]
Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide

Solution:-

Asteroid Collision simulates asteroid collisions using stack. Right-moving vs left-moving collision resolution.

#Java Implementation (Stack Simulation)

class Solution {
    public int[] asteroidCollision(int[] asteroids) {
        Stack<Integer> stack = new Stack<>();
        
        for (int asteroid : asteroids) {
            boolean destroy = false;
            
            // Handle left-moving colliding with right-moving stack top
            while (!stack.isEmpty() && stack.peek() > 0 && asteroid < 0) {
                int top = stack.peek();
                
                // Current destroys stack top
                if (Math.abs(asteroid) > top) {
                    stack.pop();
                }
                // Same size - both destroyed
                else if (Math.abs(asteroid) == top) {
                    stack.pop();
                    destroy = true;
                    break;
                }
                // Stack top destroys current
                else {
                    destroy = true;
                    break;
                }
            }
            
            // Survives collision
            if (!destroy) {
                stack.push(asteroid);
            }
        }
        
        // Convert stack to array
        int[] result = new int[stack.size()];
        for (int i = result.length - 1; i >= 0; i--) {
            result[i] = stack.pop();
        }
        return result;
    }
}

Stack: Remaining asteroids after collisions.

#Step-by-Step Logic
Stack: Asteroids that survived so far
For each asteroid:
Same direction: Always survives → push
Right → Left collision (stack.top>0 && asteroid<0):
|asteroid| > stack.top: Destroy top, continue
|asteroid| == stack.top: Both destroy
|asteroid| < stack.top: Current destroys
Result: Stack → array (reverse order)
Trace: [5,10,-5]

text
5: stack=[5]
10: stack=[5,10] (both right)
-5: collide with 10 → |5|==10? NO → |5|<10 → -5 destroys
stack=[5,10] ✓

#Thought Process
Key insight: Same direction asteroids never collide

text
Right+Right, Left+Left → no meet
Only Right→Left collisions matter
Stack simulates space:

text
Stack top = rightmost surviving asteroid
New asteroid collides only with stack top
Collision resolution:

text
Size comparison determines survivor
Equal → both explode
Time: O(n), Space: O(n)

#Edge Cases
All same direction: [1,2,3] → unchanged
All collisions: [10,-11] → [-11]
Multiple collisions: [5,10,-13] → [-13]
Empty: [] → []
