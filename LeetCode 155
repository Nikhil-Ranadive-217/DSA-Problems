Problem:- Min Stack
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

Implement the MinStack class:

MinStack() initializes the stack object.
void push(int val) pushes the element val onto the stack.
void pop() removes the element on the top of the stack.
int top() gets the top element of the stack.
int getMin() retrieves the minimum element in the stack.
You must implement a solution with O(1) time complexity for each function.

Example 1:

Input
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

Output
[null,null,null,null,-3,null,0,-2]

Explanation
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // return -3
minStack.pop();
minStack.top();    // return 0
minStack.getMin(); // return -2

Solutions:-

Min Stack implements stack with O(1) min retrieval. Dual stack approach: main + min tracking.

#Java Implementation (Dual Stack)

class MinStack {
    private Stack<Integer> stack;
    private Stack<Integer> minStack;
    
    public MinStack() {
        stack = new Stack<>();
        minStack = new Stack<>();
    }
    
    public void push(int val) {
        stack.push(val);
        
        // Push current min to minStack
        if (minStack.isEmpty()) {
            minStack.push(val);
        } else {
            minStack.push(Math.min(val, minStack.peek()));
        }
    }
    
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}

minStack: Always stores current minimum at each stack level.

#Step-by-Step Logic
push(val):
stack.push(val)
minStack.push(min(val, prev_min))
pop(): Remove both stack tops
top(): stack.peek()
getMin(): minStack.peek() → current min O(1)
Trace: push(-2), push(0), push(-3)

text
push(-2): stack=[-2], minStack=[-2]
push(0):  stack=[-2,0], minStack=[-2,min(0,-2)=-2]  
push(-3): stack=[-2,0,-3], minStack=[-2,-2,min(-3,-2)=-3]
getMin(): -3 ✓, top(): -3 ✓

#Thought Process
Challenge: O(1) min with push/pop changing mins

text
Naive: scan stack → O(n)
Solution: minStack tracks min at EACH level
Why Math.min(val, prev_min):

text
New min ≤ current min → new min
New val > current min → keep current min
minStack always has correct min at top!
Space trade-off: O(n) for O(1) operations

#Alternatives:
Single stack + pair storage: more complex
Linked list nodes: higher constants

#Edge Cases
Empty: Operations undefined (per constraints)
Single element: min = element ✓
Increasing: minStack stable
Decreasing: minStack updates
Mixed: Handles perfectly
