#Problem Statement:
Contains Duplicate checks if any value appears at least twice in integer array nums, returning true for duplicates or false if all distinct. 
Constraints: 1 ≤ nums.length ≤ 10^5, -10^9 ≤ nums[i] ≤ 10^9.
​

#Java Implementation:-

class Solution {
    public boolean containsDuplicate(int[] nums) {
        Set<Integer> seen = new HashSet<>();
        for (int num : nums) {
            if (seen.contains(num)) {
                return true;
            }
            seen.add(num);
        }
        return false;
    }
}

Note:-
Optimal O(n) time, O(n) space using HashSet for O(1) lookups.
​
​

#Thought Process:-
Brute force nested loops compare pairs (O(n²) time), too slow for n=10^5. Sorting first then adjacent checks (O(n log n) time, O(1) space if in-place) works but destroys order.
​
HashSet best: track seen elements. Check existence before adding; duplicate triggers early return. Handles negatives/zeroes/duplicates perfectly; space trade-off worth it for speed.
​
Java HashSet auto-handles uniqueness, no overwrite needed unlike maps.
​

#Step-by-Step Logic:-
1.Initialize empty HashSet<Integer> seen.

2.For each num in nums:

3.If seen.contains(num), return true.

4.Else seen.add(num).

5.Loop ends: return false (no duplicates).
​

#Edge Cases:-
1.Single element: [1] → false; empty set never finds match.
​
2.All duplicates: [1,1,1] → true on second 1.
​
3.Mixed positions: [1,2,3,1] → true at last 1.
​
4.Negatives: [-1,-1] → true; HashSet handles negatives.
​
5.Zeroes: [0,0] → true.
​
6.Large range: nums[i]=10^9 or -10^9; int fine, no overflow.
​
7.Max size n=10^5: HashSet resizes efficiently.
